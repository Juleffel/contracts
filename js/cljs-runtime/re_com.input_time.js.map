{"version":3,"sources":["re_com/input_time.cljs"],"mappings":"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","names":["re-com.input-time/time->mins","time","cljs.core/rem","re-com.input-time/time->hrs","cljs.core/quot","re-com.input-time/to-int","s","val","js/parseInt","js/isNaN","p__45518","vec__45520","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","re-com.input-time/triple->time","hr","_","mi","re-com.input-time/triple-seeking-re","re-com.input-time/extract-triple-from-text","text","cljs.core/re-matches","cljs.core/rest","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","cljs.core/not","cljs.core/nil?","re-com.input-time/text->time","cljs.core.map.cljs$core$IFn$_invoke$arity$2","re-com.input-time/time->text","hrs","mins","re-com.util/pad-zero-number","re-com.input-time/valid-text?","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/count","re-com.input-time/valid-time?","re-com.input-time/validate-arg-times","model","minimum","maximum","js/Error","re-com.input-time/force-valid-time","min","max","previous","re-com.input-time/on-new-keypress","event","text-model","current-text","cljs.core/reset!","re-com.input-time/lose-focus-if-enter","ev","re-com.input-time/on-defocus","callback","previous-val","cljs.core/deref","and__4174__auto__","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","re-com.input-time/input-time-args-desc","re-com.validate/number-or-string?","cljs.core/fn?","cljs.core/string?","re-com.validate/css-style?","re-com.validate/html-attr?","var_args","args__4795__auto__","len__4789__auto__","i__4790__auto__","argseq__4796__auto__","cljs.core/IndexedSeq","re-com.input-time/input-time","p__45568","map__45570","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","cljs.core.get.cljs$core$IFn$_invoke$arity$3","seq45566","self__4777__auto__","cljs.core/seq","args","js/goog.DEBUG","re_com.validate.validate_args.cljs$core$IFn$_invoke$arity$variadic","re-com.validate/extract-arg-data","re-com.util/deref-or-value","deref-model","reagent.core.atom.cljs$core$IFn$_invoke$arity$1","previous-model","p__45573","map__45576","on-change","disabled?","show-icon?","hide-border?","width","height","class","style","attr","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","new-val","re-com.box/h-box"],"sourcesContent":["(ns re-com.input-time\r\n  (:require-macros [re-com.core :refer [handler-fn]])\r\n  (:require [reagent.core    :as    reagent]\r\n            [re-com.validate :refer [css-style? html-attr? number-or-string?] :refer-macros [validate-args-macro]]\r\n            [re-com.text     :refer [label]]\r\n            [re-com.box      :refer [h-box gap]]\r\n            [re-com.util     :refer [pad-zero-number deref-or-value]]))\r\n\r\n\r\n(defn- time->mins\r\n  [time]\r\n  (rem time 100))\r\n\r\n\r\n(defn- time->hrs\r\n  [time]\r\n  (quot time 100))\r\n\r\n(defn- to-int\r\n  \"Parse the string 's' to a valid int. On parse failure, return 0\"\r\n  [s]\r\n  (let [val (js/parseInt s)]\r\n    (if (js/isNaN val) 0 val)))\r\n\r\n(defn- triple->time\r\n  \"Return a time integer from a triple int vector of form  [H  _  M]\"\r\n  [[hr _ mi]]\r\n  (+ (* hr 100) mi))                                        ;; a four digit integer:  HHMM\r\n\r\n\r\n;; This regular expression matchs all valid forms of time entry, including partial\r\n;; forms which happen during user entry.\r\n;; It is composed of 3 'or' options, separated by '|',  and within each, is a sub-re which\r\n;; attempts to match the HH ':' MM parts.\r\n;; So any attempt to match against this re, using \"re-matches\" will return\r\n;; a vector of 10 items:\r\n;;   - the 1st item will be the entire string matched\r\n;;   - followed by 3 groups of 3.\r\n(def ^{:private true}\r\n  triple-seeking-re #\"^(\\d{0,2})()()$|^(\\d{0,1})(:{0,1})(\\d{0,2})$|^(\\d{0,2})(:{0,1})(\\d{0,2})$\")\r\n\r\n(defn- extract-triple-from-text\r\n  [text]\r\n  (->> text\r\n       (re-matches triple-seeking-re)                       ;; looks for different ways of matching triples   H : M\r\n       (rest)                                               ;; get rid of the first value. It is the entire matched string.\r\n       (filter (comp not nil?))))                           ;; of the 9 items, there should be only 3 non-nil matches coresponding to  H : M\r\n\r\n\r\n(defn- text->time\r\n  \"return as a time int, the contents of 'text'\"\r\n  [text]\r\n  (->> text\r\n       extract-triple-from-text\r\n       (map to-int)                                         ;; make them ints (or 0)\r\n       triple->time))                                       ;; turn the triple of values into a single int\r\n\r\n\r\n(defn- time->text\r\n  \"return a string of format HH:MM for 'time'\"\r\n  [time]\r\n  (let [hrs  (time->hrs  time)\r\n        mins (time->mins time)]\r\n    (str (pad-zero-number hrs 2) \":\" (pad-zero-number mins 2))))\r\n\r\n(defn- valid-text?\r\n  \"Return true if text passes basic time validation.\r\n   Can't do to much validation because user input might not be finished.\r\n   Why?  On the way to entering 6:30, you must pass through the invalid state of '63'.\r\n   So we only really check against the triple-extracting regular expression\"\r\n  [text]\r\n  (= 3 (count (extract-triple-from-text text))))\r\n\r\n(defn- valid-time?\r\n  [time]\r\n  (cond\r\n    (nil? time) false                                       ;; can't be nil\r\n    (> 0 time) false                                        ;; must be a poistive number\r\n    (< 60 (time->mins time)) false                          ;; too many mins\r\n    :else true))\r\n\r\n(defn- validate-arg-times\r\n  [model minimum maximum]\r\n  (assert (and (number? model) (valid-time? model)) (str \"[input-time] given an invalid :model - \" model))\r\n  (assert (and (number? minimum) (valid-time? minimum)) (str \"[input-time] given an invalid :minimum - \" minimum))\r\n  (assert (and (number? maximum) (valid-time? maximum)) (str \"[input-time] given an invalid :maximum - \" maximum))\r\n  (assert (<= minimum maximum) (str \"[input-time] :minimum \" minimum \" > :maximum  \" maximum))\r\n  true)\r\n\r\n(defn- force-valid-time\r\n  \"Validate the time supplied.\r\n   Return either the time or, if it is invalid, return something valid\"\r\n  [time min max previous]\r\n  (cond\r\n    (nil? time) previous\r\n    (not (valid-time? time)) previous\r\n    (< time min) min\r\n    (< max time) max\r\n    :else time))\r\n\r\n(defn- on-new-keypress\r\n  \"Called each time the <input> field gets a keypress, or paste operation.\r\n   Rests  the text-model only if the new text is valid\"\r\n  [event text-model]\r\n  (let [current-text (-> event .-target .-value)]           ;; gets the current input field text\r\n    (when (valid-text? current-text)\r\n      (reset! text-model current-text))))\r\n\r\n(defn- lose-focus-if-enter\r\n  \"When Enter is pressed, force the component to lose focus\"\r\n  [ev]\r\n  (when (= (.-keyCode ev) 13)\r\n    (-> ev .-target .blur)\r\n    true))\r\n\r\n(defn- on-defocus\r\n  \"Called when the field looses focus.\r\n   Re-validate what has been entered, comparing to mins and maxs.\r\n   Invoke the callback as necessary\"\r\n  [text-model min max callback previous-val]\r\n  (let [time (text->time @text-model)\r\n        time (force-valid-time time min max previous-val)]\r\n    (reset! text-model (time->text time))\r\n    (when (and callback (not= time previous-val))\r\n      (callback time))))\r\n\r\n(def input-time-args-desc\r\n  [{:name :model        :required true                   :type \"integer | string | atom\" :validate-fn number-or-string? :description \"a time in integer form. e.g. '09:30am' is 930\"}\r\n   {:name :on-change    :required true                   :type \"integer -> nil\"          :validate-fn fn?               :description \"called when user entry completes and value is new. Passed new value as integer\"}\r\n   {:name :minimum      :required false :default 0       :type \"integer | string\"        :validate-fn number-or-string? :description \"user can't enter a time less than this value\"}\r\n   {:name :maximum      :required false :default 2359    :type \"integer | string\"        :validate-fn number-or-string? :description \"user can't enter a time more than this value\"}\r\n   {:name :disabled?    :required false :default false   :type \"boolean | atom\"                                         :description \"when true, user input is disabled\"}\r\n   {:name :show-icon?   :required false :default false   :type \"boolean\"                                                :description \"when true, a clock icon will be displayed to the right of input field\"}\r\n   {:name :hide-border? :required false :default false   :type \"boolean\"                                                :description \"when true, input filed is displayed without a border\"}\r\n   {:name :width        :required false                  :type \"string\"                  :validate-fn string?           :description \"standard CSS width setting for width of the input box (excluding the icon if present)\"}\r\n   {:name :height       :required false                  :type \"string\"                  :validate-fn string?           :description \"standard CSS height setting\"}\r\n   {:name :class        :required false                  :type \"string\"                  :validate-fn string?           :description \"CSS class names, space separated\"}\r\n   {:name :style        :required false                  :type \"CSS style map\"           :validate-fn css-style?        :description \"CSS style. e.g. {:color \\\"red\\\" :width \\\"50px\\\"}\" }\r\n   {:name :attr         :required false                  :type \"HTML attr map\"           :validate-fn html-attr?        :description [:span \"HTML attributes, like \" [:code \":on-mouse-move\"] [:br] \"No \" [:code \":class\"] \" or \" [:code \":style\"] \"allowed\"]}])\r\n\r\n(defn input-time\r\n  \"I return the markup for an input box which will accept and validate times.\r\n   Parameters - refer input-time-args above\"\r\n  [& {:keys [model minimum maximum] :as args\r\n      :or   {minimum 0 maximum 2359}}]\r\n  {:pre [(validate-args-macro input-time-args-desc args \"input-time\")\r\n         (validate-arg-times (deref-or-value model) minimum maximum)]}\r\n  (let [deref-model    (deref-or-value model)\r\n        text-model     (reagent/atom (time->text deref-model))\r\n        previous-model (reagent/atom deref-model)]\r\n    (fn\r\n      [& {:keys [model on-change minimum maximum disabled? show-icon? hide-border? width height class style attr] :as args\r\n          :or   {minimum 0 maximum 2359}}]\r\n      {:pre [(validate-args-macro input-time-args-desc args \"input-time\")\r\n             (validate-arg-times (deref-or-value model) minimum maximum)]}\r\n      (let [style (merge (when hide-border? {:border \"none\"})\r\n                         style)\r\n            new-val (deref-or-value model)\r\n            new-val (if (< new-val minimum) minimum new-val)\r\n            new-val (if (> new-val maximum) maximum new-val)]\r\n        ;; if the model is different to that currently shown in text, then reset the text to match\r\n        ;; other than that we want to keep the current text, because the user is probably typing\r\n        (when (not= @previous-model new-val)\r\n          (reset! text-model (time->text new-val))\r\n          (reset! previous-model new-val))\r\n\r\n        [h-box\r\n         :class    \"rc-input-time\"\r\n         :style    (merge {:height height}\r\n                          style)\r\n         :children [[:input\r\n                     (merge\r\n                       {:type      \"text\"\r\n                        :class     (str \"time-entry \" class)\r\n                        :style     (merge {:width width}\r\n                                          style)\r\n                        :value     @text-model\r\n                        :disabled  (deref-or-value disabled?)\r\n                        :on-change (handler-fn (on-new-keypress event text-model))\r\n                        :on-blur   (handler-fn (on-defocus text-model minimum maximum on-change @previous-model))\r\n                        :on-key-up (handler-fn (lose-focus-if-enter event))}\r\n                       attr)]\r\n                    (when show-icon?\r\n                      #_[:div.time-icon ;; TODO: Remove\r\n                       [:span.glyphicon.glyphicon-time\r\n                        {:style {:position \"static\" :margin \"auto\"}}]]\r\n                      [:div.time-icon\r\n                       [:i.zmdi.zmdi-hc-fw-rc.zmdi-time\r\n                        {:style {:position \"static\" :margin \"auto\"}}]])]]))))\r\n"]}